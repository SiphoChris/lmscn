{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "fill-blank",
  "type": "registry:component",
  "title": "Fill in the Blank",
  "description": "Inline blank-filling exercise supporting multiple blanks per sentence, alternative accepted answers and keyboard navigation.",
  "registryDependencies": [
    "button",
    "input",
    "progress",
    "badge"
  ],
  "files": [
    {
      "path": "registry/default/fill-blank/fill-blank.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { useState, useCallback, useRef } from \"react\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Progress } from \"@/components/ui/progress\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { CheckCircle2, XCircle, ChevronRight } from \"lucide-react\"\n\n// ─── Types ────────────────────────────────────────────────────────────────────\n\nexport interface FillBlankQuestion {\n  id: string\n  /**\n   * Sentence with blanks marked as `___`.\n   * e.g. \"The capital of France is ___ and it sits on the ___ river.\"\n   */\n  sentence: string\n  /** Correct answer for each blank, in order */\n  answers: string[]\n  /** Case-sensitive matching (default: false) */\n  caseSensitive?: boolean\n  /**\n   * Per-blank list of accepted alternatives (same index as answers).\n   * e.g. [[\"mitochondrion\"], [\"cell\"]]\n   */\n  alternatives?: Array<string[]>\n  hint?: string\n}\n\nexport interface FillBlankData {\n  title: string\n  description?: string\n  questions: FillBlankQuestion[]\n  /** Show the correct answer when the user is wrong (default: true) */\n  showCorrection?: boolean\n}\n\nexport interface FillBlankAttempt {\n  questionId: string\n  given: string[]\n  correct: boolean\n}\n\nexport interface FillBlankResult {\n  attempts: FillBlankAttempt[]\n  score: number\n  maxScore: number\n  percentage: number\n}\n\nexport interface FillBlankProps {\n  fillBlankData: FillBlankData\n  onComplete?: (result: FillBlankResult) => void\n  className?: string\n}\n\n// ─── Helpers ──────────────────────────────────────────────────────────────────\n\nconst BLANK_TOKEN = \"___\"\n\ntype SentencePart =\n  | { type: \"text\"; content: string }\n  | { type: \"blank\" }\n\nfunction parseSentence(sentence: string): SentencePart[] {\n  const parts = sentence.split(BLANK_TOKEN)\n  const result: SentencePart[] = []\n  for (let i = 0; i < parts.length; i++) {\n    if (parts[i]) result.push({ type: \"text\", content: parts[i] })\n    if (i < parts.length - 1) result.push({ type: \"blank\" })\n  }\n  return result\n}\n\nfunction checkAnswer(\n  given: string,\n  correct: string,\n  alts: string[] | undefined,\n  caseSensitive: boolean\n): boolean {\n  const norm = (s: string) =>\n    caseSensitive ? s.trim() : s.trim().toLowerCase()\n  return [correct, ...(alts ?? [])].map(norm).includes(norm(given))\n}\n\n// ─── Component ────────────────────────────────────────────────────────────────\n\nexport function FillBlank({\n  fillBlankData,\n  onComplete,\n  className,\n}: FillBlankProps) {\n  const {\n    title,\n    description,\n    questions,\n    showCorrection = true,\n  } = fillBlankData\n\n  const [index, setIndex] = useState(0)\n  const [inputs, setInputs] = useState<string[]>([])\n  const [submitted, setSubmitted] = useState(false)\n  const [attempts, setAttempts] = useState<FillBlankAttempt[]>([])\n  const [finished, setFinished] = useState(false)\n  const inputRefs = useRef<Array<HTMLInputElement | null>>([])\n\n  const question = questions[index]\n  const parts = React.useMemo(\n    () => parseSentence(question.sentence),\n    [question.sentence]\n  )\n  const blankCount = parts.filter((p) => p.type === \"blank\").length\n\n  const progress = (index / questions.length) * 100\n\n  React.useEffect(() => {\n    setInputs(Array(blankCount).fill(\"\"))\n    setTimeout(() => inputRefs.current[0]?.focus(), 50)\n  }, [index, blankCount])\n\n  const handleInput = useCallback((bi: number, value: string) => {\n    setInputs((prev) => {\n      const next = [...prev]\n      next[bi] = value\n      return next\n    })\n  }, [])\n\n  const results = React.useMemo(() => {\n    if (!submitted) return []\n    return inputs.map((given, i) =>\n      checkAnswer(\n        given,\n        question.answers[i] ?? \"\",\n        question.alternatives?.[i],\n        question.caseSensitive ?? false\n      )\n    )\n  }, [submitted, inputs, question])\n\n  const handleSubmit = useCallback(() => {\n    if (inputs.some((v) => !v.trim())) return\n    setSubmitted(true)\n  }, [inputs])\n\n  const handleNext = useCallback(() => {\n    const attempt: FillBlankAttempt = {\n      questionId: question.id,\n      given: inputs,\n      correct: results.every(Boolean),\n    }\n    const newAttempts = [...attempts, attempt]\n    setAttempts(newAttempts)\n\n    if (index + 1 >= questions.length) {\n      const score = newAttempts.filter((a) => a.correct).length\n      const res: FillBlankResult = {\n        attempts: newAttempts,\n        score,\n        maxScore: questions.length,\n        percentage: Math.round((score / questions.length) * 100),\n      }\n      setFinished(true)\n      onComplete?.(res)\n    } else {\n      setIndex((i) => i + 1)\n      setSubmitted(false)\n    }\n  }, [\n    question.id,\n    inputs,\n    results,\n    attempts,\n    index,\n    questions.length,\n    onComplete,\n  ])\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent, bi: number) => {\n      if (e.key === \"Enter\") {\n        if (bi + 1 < blankCount) {\n          inputRefs.current[bi + 1]?.focus()\n        } else {\n          handleSubmit()\n        }\n      }\n    },\n    [blankCount, handleSubmit]\n  )\n\n  // ── Finished ──────────────────────────────────────────────────────────────\n  if (finished) {\n    const score = attempts.filter((a) => a.correct).length\n    const pct = Math.round((score / questions.length) * 100)\n    return (\n      <div\n        className={cn(\n          \"w-full max-w-2xl mx-auto text-center space-y-4\",\n          className\n        )}\n      >\n        <h2 className=\"text-2xl font-bold\">Complete!</h2>\n        <p className=\"text-5xl font-bold\">{pct}%</p>\n        <p className=\"text-muted-foreground\">\n          {score} / {questions.length} correct\n        </p>\n      </div>\n    )\n  }\n\n  // ── Render ────────────────────────────────────────────────────────────────\n  let blankIdx = 0\n\n  return (\n    <div className={cn(\"w-full max-w-2xl mx-auto space-y-6\", className)}>\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h2 className=\"font-semibold text-lg\">{title}</h2>\n          {description && (\n            <p className=\"text-sm text-muted-foreground\">{description}</p>\n          )}\n        </div>\n        <Badge variant=\"outline\">\n          {index + 1} / {questions.length}\n        </Badge>\n      </div>\n\n      <Progress value={progress} className=\"h-1.5\" />\n\n      <div className=\"rounded-xl border bg-card p-6 space-y-4\">\n        {question.hint && !submitted && (\n          <p className=\"text-sm text-muted-foreground italic\">\n            Hint: {question.hint}\n          </p>\n        )}\n\n        {/* Sentence with inline inputs */}\n        <p className=\"text-base leading-relaxed flex flex-wrap items-center gap-1\">\n          {parts.map((part, i) => {\n            if (part.type === \"text\") {\n              return <span key={i}>{part.content}</span>\n            }\n            const bi = blankIdx++\n            const isCorrectBlank = submitted ? results[bi] : undefined\n            return (\n              <span key={i} className=\"inline-flex items-center gap-1\">\n                <Input\n                  ref={(el) => {\n                    inputRefs.current[bi] = el\n                  }}\n                  value={inputs[bi] ?? \"\"}\n                  onChange={(e) => handleInput(bi, e.target.value)}\n                  onKeyDown={(e) => handleKeyDown(e, bi)}\n                  disabled={submitted}\n                  className={cn(\n                    \"h-8 min-w-[6rem] max-w-[12rem] text-center text-sm\",\n                    submitted &&\n                      isCorrectBlank &&\n                      \"border-green-500 bg-green-50 dark:bg-green-950/20\",\n                    submitted &&\n                      !isCorrectBlank &&\n                      \"border-destructive bg-destructive/5\"\n                  )}\n                  aria-label={`Blank ${bi + 1}`}\n                />\n                {submitted && isCorrectBlank && (\n                  <CheckCircle2 className=\"size-4 text-green-600 shrink-0\" />\n                )}\n                {submitted && !isCorrectBlank && (\n                  <XCircle className=\"size-4 text-destructive shrink-0\" />\n                )}\n              </span>\n            )\n          })}\n        </p>\n\n        {/* Corrections */}\n        {submitted && showCorrection && !results.every(Boolean) && (\n          <div className=\"mt-2 rounded-md bg-muted px-4 py-3 text-sm space-y-1\">\n            <p className=\"font-medium\">Correct answers:</p>\n            {question.answers.map((ans, i) => (\n              <p key={i} className=\"text-muted-foreground\">\n                Blank {i + 1}:{\" \"}\n                <span className=\"text-foreground font-medium\">{ans}</span>\n              </p>\n            ))}\n          </div>\n        )}\n      </div>\n\n      <div className=\"flex justify-end\">\n        {!submitted ? (\n          <Button\n            onClick={handleSubmit}\n            disabled={inputs.some((v) => !v.trim())}\n          >\n            Check\n          </Button>\n        ) : (\n          <Button onClick={handleNext}>\n            {index + 1 >= questions.length ? \"See Results\" : \"Next\"}\n            <ChevronRight className=\"ml-1 size-4\" />\n          </Button>\n        )}\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}